<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escribir con Señas</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        h1, h2 {
            color: #1877f2;
        }
        #container {
            position: relative;
            width: 640px;
            height: 480px;
            border: 2px solid #1877f2;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        #video {
            display: block;
            width: 100%;
            height: 100%;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #output-container {
            margin-top: 20px;
            text-align: center;
            width: 100%;
            max-width: 640px;
        }
        #recognized-text {
            font-size: 2.5em;
            min-height: 60px;
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
            word-wrap: break-word;
        }
        #feedback-buttons, #message-container {
            margin-top: 15px;
            height: 40px; /* Reserve space to prevent layout shifts */
        }
        #message {
            color: #d93025;
            font-weight: bold;
            font-size: 1.1em;
        }
        button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 10px;
            transition: background-color 0.3s, transform 0.1s;
        }
        #btn-correct { background-color: #42b72a; color: white; }
        #btn-correct:hover { background-color: #36a420; }
        #btn-incorrect { background-color: #fa383e; color: white; }
        #btn-incorrect:hover { background-color: #e02c32; }
        #save-data { background-color: #1877f2; color: white; margin-top: 20px; }
        #save-data:hover { background-color: #166fe5; }
        button:active {
            transform: scale(0.95);
        }
        #json-loader {
            padding: 20px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 20px;
            background-color: #fff;
        }
        #json-file-input {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Escribir con Lenguaje de Señas</h1>

    <div id="json-loader">
        <label for="json-file-input">Para comenzar, carga tu archivo <code>cerebro-ia-basico.json</code>:</label>
        <br>
        <input type="file" id="json-file-input" accept=".json">
    </div>

    <div id="container" style="display: none;">
        <video id="video" width="640" height="480" autoplay playsinline></video>
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>
    <div id="output-container" style="display: none;">
        <h2>Texto Reconocido:</h2>
        <p id="recognized-text"></p>
        <div id="feedback-buttons" style="display: none;">
            <button id="btn-correct">Bien</button>
            <button id="btn-incorrect">Mal</button>
        </div>
        <div id="message-container">
            <div id="message" style="display: none;">Vuelve a hacer la última letra</div>
        </div>
        <button id="save-data">Guardar Datos de Entrenamiento</button>
    </div>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.10";

        const video = document.getElementById('video');
        const canvasElement = document.getElementById('canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const recognizedTextElement = document.getElementById('recognized-text');
        const feedbackButtons = document.getElementById('feedback-buttons');
        const messageEl = document.getElementById('message');
        const btnCorrect = document.getElementById('btn-correct');
        const btnIncorrect = document.getElementById('btn-incorrect');
        const saveDataBtn = document.getElementById('save-data');
        
        const jsonFileInput = document.getElementById('json-file-input');
        const jsonLoaderDiv = document.getElementById('json-loader');
        const containerDiv = document.getElementById('container');
        const outputContainerDiv = document.getElementById('output-container');

        let handLandmarker;
        let runningMode = "VIDEO";
        let knownGestures = [];
        let retrainingData = []; // Almacenará los gestos marcados como incorrectos
        const KNN_K = 3; // Usar los 3 vecinos más cercanos para la predicción

        // --- Configuración y Estado ---
        const STATIC_HOLD_TIME = 1000; // 1 segundo para confirmar una letra estática
        const NO_HAND_SPACE_TIME = 2000; // 2 segundos sin mano para un espacio
        const PREDICTION_INTERVAL = 100; // ms, hacer predicción cada 100ms (10 veces por segundo) para no sobrecargar.
        let lastPredictionTime = 0;
        let currentCandidate = null;
        let candidateStartTime = 0;
        let lastRecognizedLetter = '';
        let noHandTimer = null;
        let lastCapturedLandmarks = null; // Almacena los landmarks del último gesto reconocido

        // --- Funciones Principales ---

        const createHandLandmarker = async () => {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.10/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                console.log("HandLandmarker creado.");
            } catch(error) {
                console.error("Error al crear HandLandmarker:", error);
                alert("No se pudo iniciar el reconocimiento de manos. Revisa la consola para más detalles. Puede que tu navegador o hardware no sea compatible con la aceleración GPU.");
            }
        };

        const processGestures = (data) => {
            try {
                knownGestures = data.map(gesture => {
                    if (gesture.type === 'dinamico' && Array.isArray(gesture.landmarks) && gesture.landmarks.length > 0 && Array.isArray(gesture.landmarks[0])) {
                        return { ...gesture, landmarks: gesture.landmarks[0], type: 'estatico' };
                    }
                    return gesture;
                }).filter(gesture => gesture.landmarks && gesture.landmarks.length > 0);
                console.log("Cerebro IA cargado y procesado.");
            } catch (error) {
                console.error("Error al procesar los gestos del archivo:", error);
                alert("Hubo un problema al procesar los datos de los gestos.");
            }
        };

        const enableCam = () => {
            if (!handLandmarker) {
                console.log("HandLandmarker no está listo aún.");
                return;
            }
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
            }).catch(err => {
                console.error("Error al acceder a la cámara: ", err);
                alert("Error al acceder a la cámara. Asegúrate de haber dado permiso y que no esté siendo usada por otra aplicación.");
            });
        };

        let lastVideoTime = -1;
        const predictWebcam = async () => {
            canvasElement.style.width = video.videoWidth + 'px';
            canvasElement.style.height = video.videoHeight + 'px';
            canvasElement.width = video.videoWidth;
            canvasElement.height = video.videoHeight;

            let startTimeMs = performance.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, startTimeMs);
                handleResults(results);
            }
            window.requestAnimationFrame(predictWebcam);
        };

        const handleResults = (results) => {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            if (results.landmarks && results.landmarks.length > 0) {
                if (noHandTimer) {
                    clearTimeout(noHandTimer);
                    noHandTimer = null;
                }
                const landmarks = results.landmarks[0];
                drawHandResults(results.landmarks); // Dibujar siempre para que se vea fluido.

                const now = performance.now();
                // Solo ejecutar la lógica de reconocimiento pesada cada cierto intervalo.
                if (now - lastPredictionTime > PREDICTION_INTERVAL) {
                    lastPredictionTime = now;
                    const normalizedLandmarks = normalizeLandmarks(landmarks);
                    const recognizedLetter = knn_predict(normalizedLandmarks);

                    if (recognizedLetter) {
                        if (recognizedLetter !== currentCandidate) {
                            currentCandidate = recognizedLetter;
                            candidateStartTime = Date.now();
                        } else if (Date.now() - candidateStartTime > STATIC_HOLD_TIME && currentCandidate !== lastRecognizedLetter) {
                            if (lastRecognizedLetter !== currentCandidate) {
                                lastCapturedLandmarks = landmarks;
                                addLetterToScreen(currentCandidate);
                            }
                        }
                    }
                }
            } else {
                // No se detecta mano
                currentCandidate = null;
                // Si no hay un temporizador activo y la última acción no fue agregar un espacio, inicia el temporizador.
                if (!noHandTimer && lastRecognizedLetter !== ' ' && recognizedTextElement.innerText.length > 0) {
                    noHandTimer = setTimeout(() => {
                        recognizedTextElement.innerText += ' ';
                        lastRecognizedLetter = ' '; // Marca que se agregó un espacio para no agregar más.
                        noHandTimer = null;
                    }, NO_HAND_SPACE_TIME); 
                }
            }
        };

        // --- Funciones de Utilidad ---

        function normalizeLandmarks(landmarks) {
            const wrist = landmarks[0];
            // 1. Centrar en la muñeca.
            const centered = landmarks.map(p => ({ x: p.x - wrist.x, y: p.y - wrist.y, z: p.z - wrist.z }));
            // 2. Escalar por el tamaño de la mano (distancia de la muñeca al dedo medio).
            const size = Math.sqrt(centered[9].x**2 + centered[9].y**2 + centered[9].z**2) || 1;
            return centered.map(p => ({ x: p.x / size, y: p.y / size, z: p.z / size }));
        }

        function calculateDistance(lm1, lm2) {
            let totalDistance = 0;
            if (!lm1 || !lm2 || lm1.length !== lm2.length) {
                return Infinity;
            }
            for (let i = 0; i < lm1.length; i++) {
                totalDistance += Math.sqrt( // Distancia euclidiana entre cada punto
                    (lm1[i].x - lm2[i].x)**2 +
                    (lm1[i].y - lm2[i].y)**2 +
                    (lm1[i].z - lm2[i].z)**2
                );
            }
            return totalDistance;
        }

        function knn_predict(currentLandmarks) {
            if (knownGestures.length === 0) return "?";

            // Calcular distancias a todas las muestras en la base de datos
            const distances = knownGestures.map(sample => {
                return { label: sample.label, distance: calculateDistance(currentLandmarks, sample.landmarks) };
            });

            // Ordenar por la menor distancia
            distances.sort((a, b) => a.distance - b.distance);

            // Tomar los K vecinos más cercanos
            const kNearest = distances.slice(0, KNN_K);
            
            // Contar los votos de los vecinos
            const votes = {};
            kNearest.forEach(neighbor => {
                votes[neighbor.label] = (votes[neighbor.label] || 0) + 1;
            });

            // Devolver el gesto con más votos
            let bestGuess = null;
            let maxVotes = 0;
            for (const label in votes) {
                if (votes[label] > maxVotes) {
                    maxVotes = votes[label];
                    bestGuess = label;
                }
            }
            return bestGuess;
        }

        const addLetterToScreen = (letter) => {
            messageEl.style.display = 'none';
            feedbackButtons.style.display = 'none'; // Oculta los botones de la letra anterior para mostrar los nuevos.

            recognizedTextElement.innerText += letter;
            lastRecognizedLetter = letter; // Actualiza la última letra reconocida.

            feedbackButtons.style.display = 'block'; // Muestra los botones de feedback para la nueva letra.
        };

        const drawHandResults = (handLandmarks) => {
            for (const landmarks of handLandmarks) {
                // Usar las utilidades de dibujo de MediaPipe
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS,
                               {color: '#00FF00', lineWidth: 5});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 2, radius: 5});
            }
        };

        const saveForRetraining = () => {
            if (!lastCapturedLandmarks || !lastRecognizedLetter || lastRecognizedLetter.trim() === '') return;

            retrainingData.push({
                label: lastRecognizedLetter, // La letra que se reconoció mal
                landmarks: lastCapturedLandmarks,
                type: 'estatico'
            });
            console.log(`Guardado para reentrenamiento: Letra '${lastRecognizedLetter}'`, lastCapturedLandmarks);
        };

        const downloadJson = (data, filename) => {
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); // Crear un enlace temporal para la descarga
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("Datos de reentrenamiento descargados.");
        };

        // --- Event Listeners ---

        btnCorrect.addEventListener('click', () => {
            feedbackButtons.style.display = 'none';
            // Permite que la misma letra pueda ser reconocida de nuevo inmediatamente.
            lastRecognizedLetter = ''; 
        });

        btnIncorrect.addEventListener('click', () => {
            saveForRetraining();
            const currentText = recognizedTextElement.innerText;
            if (currentText.length > 0) {
                recognizedTextElement.innerText = currentText.slice(0, -1); // Borra la última letra.
            }
            lastRecognizedLetter = ''; // Permite que la misma letra (o una nueva) sea detectada de nuevo
            feedbackButtons.style.display = 'none';
            messageEl.style.display = 'block';
        });

        saveDataBtn.addEventListener('click', () => {
            if (retrainingData.length > 0) {
                downloadJson(retrainingData, 'debe-entrenar-las-letras.json');
                retrainingData = []; // Limpiar los datos después de guardar
            } else {
                alert("No hay datos incorrectos para guardar.");
            }
        });

        // --- Inicialización ---
        jsonFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    processGestures(data); // Process the loaded data

                    // Hide loader and show the main app UI
                    jsonLoaderDiv.style.display = 'none';
                    containerDiv.style.display = 'block';
                    outputContainerDiv.style.display = 'block';

                    // Now, initialize the camera and hand landmarker
                    await createHandLandmarker();
                    enableCam();
                    console.log("Todo listo para empezar. Activando cámara...");

                } catch (error) {
                    console.error("Error al leer o parsear el archivo JSON:", error);
                    alert("El archivo seleccionado no es un JSON válido o no se pudo leer.");
                }
            };
            reader.readAsText(file);
        });

    </script>
</body>
</html>
