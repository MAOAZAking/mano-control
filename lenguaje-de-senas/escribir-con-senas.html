<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escribir con Señas</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        h1, h2 {
            color: #1877f2;
        }
        #container {
            position: relative;
            width: 640px;
            height: 480px;
            border: 2px solid #1877f2;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        #video {
            display: block;
            width: 100%;
            height: 100%;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #output-container {
            margin-top: 20px;
            text-align: center;
            width: 100%;
            max-width: 640px;
        }
        #recognized-text {
            font-size: 2.5em;
            min-height: 60px;
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
            word-wrap: break-word;
        }
        #feedback-buttons, #message-container {
            margin-top: 15px;
            height: 40px; /* Reserve space to prevent layout shifts */
        }
        #message {
            color: #d93025;
            font-weight: bold;
            font-size: 1.1em;
        }
        button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 10px;
            transition: background-color 0.3s, transform 0.1s;
        }
        #btn-correct { background-color: #42b72a; color: white; }
        #btn-correct:hover { background-color: #36a420; }
        #btn-incorrect { background-color: #fa383e; color: white; }
        #btn-incorrect:hover { background-color: #e02c32; }
        #save-data { background-color: #1877f2; color: white; margin-top: 20px; }
        #save-data:hover { background-color: #166fe5; }
        button:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <h1>Escribir con Lenguaje de Señas</h1>
    <div id="container">
        <video id="video" width="640" height="480" autoplay playsinline></video>
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>
    <div id="output-container">
        <h2>Texto Reconocido:</h2>
        <p id="recognized-text"></p>
        <div id="feedback-buttons" style="display: none;">
            <button id="btn-correct">Bien</button>
            <button id="btn-incorrect">Mal</button>
        </div>
        <div id="message-container">
            <div id="message" style="display: none;">Vuelve a hacer la última letra</div>
        </div>
        <button id="save-data">Guardar Datos de Entrenamiento</button>
    </div>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@medipe/tasks-vision@0.10.0";

        const video = document.getElementById('video');
        const canvasElement = document.getElementById('canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const recognizedTextElement = document.getElementById('recognized-text');
        const feedbackButtons = document.getElementById('feedback-buttons');
        const messageEl = document.getElementById('message');
        const btnCorrect = document.getElementById('btn-correct');
        const btnIncorrect = document.getElementById('btn-incorrect');
        const saveDataBtn = document.getElementById('save-data');

        let handLandmarker;
        let runningMode = "VIDEO";
        let knownGestures = [];
        let retrainingData = []; // Almacenará los gestos marcados como incorrectos

        // --- Configuración y Estado ---
        const STATIC_HOLD_TIME = 1000; // 1 segundo para confirmar una letra estática
        const NO_HAND_SPACE_TIME = 2000; // 2 segundos sin mano para un espacio
        let currentCandidate = null;
        let candidateStartTime = 0;
        let lastRecognizedLetter = '';
        let noHandTimer = null;
        let isCorrecting = false;
        let lastCapturedLandmarks = null; // Almacena los landmarks del último gesto reconocido

        // --- Funciones Principales ---

        const createHandLandmarker = async () => {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@medipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                console.log("HandLandmarker creado.");
            } catch(error) {
                console.error("Error al crear HandLandmarker:", error);
                alert("No se pudo iniciar el reconocimiento de manos. Revisa la consola para más detalles. Puede que tu navegador o hardware no sea compatible con la aceleración GPU.");
            }
        };

        const loadKnownGestures = async () => {
            try {
                const response = await fetch('cerebro-ia-basico.json');
                const data = await response.json();
                knownGestures = data.map(gesture => {
                    // Para gestos dinámicos, que son más complejos, usamos el primer cuadro del gesto como una pose estática representativa.
                    // Esto es una simplificación; un reconocimiento dinámico completo requeriría un enfoque más avanzado.
                    if (gesture.type === 'dinamico' && Array.isArray(gesture.landmarks) && gesture.landmarks.length > 0 && Array.isArray(gesture.landmarks[0])) {
                        return { ...gesture, landmarks: gesture.landmarks[0], type: 'estatico' };
                    }
                    return gesture;
                }).filter(gesture => gesture.landmarks && gesture.landmarks.length > 0); // Filtra gestos sin datos
                console.log("Cerebro IA cargado.");
            } catch (error) {
                console.error("Error al cargar cerebro-ia-basico.json:", error);
                alert("No se pudo cargar el archivo de gestos. Asegúrate de que 'cerebro-ia-basico.json' esté en la misma carpeta.");
            }
        };

        const enableCam = () => {
            if (!handLandmarker) {
                console.log("HandLandmarker no está listo aún.");
                return;
            }
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
            }).catch(err => {
                console.error("Error al acceder a la cámara: ", err);
                alert("Error al acceder a la cámara. Asegúrate de haber dado permiso y que no esté siendo usada por otra aplicación.");
            });
        };

        let lastVideoTime = -1;
        const predictWebcam = async () => {
            canvasElement.style.width = video.videoWidth + 'px';
            canvasElement.style.height = video.videoHeight + 'px';
            canvasElement.width = video.videoWidth;
            canvasElement.height = video.videoHeight;

            let startTimeMs = performance.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, startTimeMs);
                handleResults(results);
            }
            window.requestAnimationFrame(predictWebcam);
        };

        const handleResults = (results) => {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            feedbackButtons.style.display = 'none'; // Ocultar botones por defecto

            if (results.landmarks && results.landmarks.length > 0) {
                if (noHandTimer) {
                    clearTimeout(noHandTimer);
                    noHandTimer = null;
                }
                const landmarks = results.landmarks[0];
                drawLandmarks(landmarks);
                const normalizedLandmarks = normalizeLandmarks(landmarks);
                
                const recognizedLetter = recognizeGesture(normalizedLandmarks);

                if (recognizedLetter) {
                    if (recognizedLetter !== currentCandidate) {
                        currentCandidate = recognizedLetter;
                        candidateStartTime = Date.now();
                    } else if (Date.now() - candidateStartTime > STATIC_HOLD_TIME && currentCandidate !== lastRecognizedLetter) {
                        if (lastRecognizedLetter !== currentCandidate || isCorrecting) {
                            lastCapturedLandmarks = landmarks;
                            addLetterToScreen(currentCandidate);
                        }
                    }
                }
            } else {
                // No se detecta mano
                currentCandidate = null;
                lastRecognizedLetter = ''; // Permite que la siguiente seña sea reconocida inmediatamente
                if (!noHandTimer && recognizedTextElement.innerText.length > 0 && !recognizedTextElement.innerText.endsWith(' ')) {
                    noHandTimer = setTimeout(() => {
                        addLetterToScreen(' ');
                        noHandTimer = null;
                    }, NO_HAND_SPACE_TIME);
                }
            }
        };

        // --- Funciones de Utilidad ---

        const normalizeLandmarks = (landmarks) => {
            const basePoint = landmarks[0];
            let normalized = landmarks.map(lm => ({
                x: lm.x - basePoint.x,
                y: lm.y - basePoint.y,
                z: lm.z - basePoint.z
            }));

            // Evitar división por cero si no hay mano o los landmarks son inválidos
            if (normalized.length === 0) return [];
            const maxDist = Math.max(...normalized.map(lm => Math.sqrt(lm.x**2 + lm.y**2 + lm.z**2)));

            normalized = normalized.map(lm => ({
                x: lm.x / maxDist,
                y: lm.y / maxDist,
                z: lm.z / maxDist
            }));
            
            return normalized;
        };

        const calculateTotalDistance = (landmarks1, landmarks2) => {
            let totalDistance = 0;
            if (!landmarks1 || !landmarks2 || landmarks1.length !== landmarks2.length) {
                return Infinity;
            }
            for (let i = 0; i < landmarks1.length; i++) {
                totalDistance += Math.sqrt(
                    (landmarks1[i].x - landmarks2[i].x)**2 +
                    (landmarks1[i].y - landmarks2[i].y)**2 +
                    (landmarks1[i].z - landmarks2[i].z)**2
                );
            }
            return totalDistance;
        };

        const recognizeGesture = (liveLandmarks) => {
            let minDistance = Infinity;
            let recognizedGesture = null;

            for (const gesture of knownGestures) {
                const distance = calculateTotalDistance(liveLandmarks, gesture.landmarks);
                if (distance < minDistance) {
                    minDistance = distance;
                    recognizedGesture = gesture.label;
                }
            }
            // Umbral de confianza: si la seña es muy diferente a todo lo conocido, no la reconozcas.
            return minDistance < 0.8 ? recognizedGesture : null; 
        };

        const addLetterToScreen = (letter) => {
            messageEl.style.display = 'none';
            // Si se está corrigiendo, la letra anterior ya fue borrada.
            // Simplemente añadimos la nueva.
            recognizedTextElement.innerText += letter;
            
            isCorrecting = false; // Se resetea el estado de corrección
            lastRecognizedLetter = letter;
            
            feedbackButtons.style.display = 'block';
        };

        const drawLandmarks = (landmarks) => {
            for (const landmark of landmarks) {
                canvasCtx.beginPath();
                canvasCtx.arc(landmark.x * canvasElement.width, landmark.y * canvasElement.height, 5, 0, 2 * Math.PI);
                canvasCtx.fillStyle = '#FF0000';
                canvasCtx.fill();
            }
        };

        const saveForRetraining = () => {
            if (!lastCapturedLandmarks || !lastRecognizedLetter || lastRecognizedLetter.trim() === '') return;

            retrainingData.push({
                label: lastRecognizedLetter, // La letra que se reconoció mal
                landmarks: lastCapturedLandmarks,
                type: 'estatico'
            });
            console.log(`Guardado para reentrenamiento: Letra '${lastRecognizedLetter}'`, lastCapturedLandmarks);
        };

        const downloadJson = (data, filename) => {
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); // Crear un enlace temporal para la descarga
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("Datos de reentrenamiento descargados.");
        };

        // --- Event Listeners ---

        btnCorrect.addEventListener('click', () => {
            feedbackButtons.style.display = 'none';
            lastRecognizedLetter = ''; // Permite que se pueda volver a escribir la misma letra
        });

        btnIncorrect.addEventListener('click', () => {
            saveForRetraining();
            const currentText = recognizedTextElement.innerText;
            if (currentText.length > 0) {
                recognizedTextElement.innerText = currentText.slice(0, -1);
            }
            isCorrecting = true;
            lastRecognizedLetter = ''; // Permite que la misma letra (o una nueva) sea detectada de nuevo
            feedbackButtons.style.display = 'none';
            messageEl.style.display = 'block';
        });

        saveDataBtn.addEventListener('click', () => {
            if (retrainingData.length > 0) {
                downloadJson(retrainingData, 'debe-entrenar-las-letras.json');
                retrainingData = []; // Limpiar los datos después de guardar
            } else {
                alert("No hay datos incorrectos para guardar.");
            }
        });

        // --- Inicialización ---
        async function start() {
            // Primero, intenta iniciar la cámara y el reconocedor de manos.
            await loadKnownGestures();
            await createHandLandmarker();
            console.log("Todo listo para empezar.");
        }
        start();

    </script>
</body>
</html>
