<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escudo M칤stico - Doctor Strange</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffcc;
            font-size: 24px;
            text-align: center;
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 1px solid #00ffcc;
            border-radius: 8px;
            transition: opacity 0.5s;
        }
        #video-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 160px;
            height: 120px;
            z-index: 5;
            opacity: 0.7;
            border: 1px solid #333;
            transform: scaleX(-1); /* Efecto espejo */
            display: none; /* Oculto por defecto, se muestra al cargar */
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 300px;
        }
    </style>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        Inicializando N칰cleo...<br>
        <small>Por favor permite el acceso a la c치mara</small>
    </div>

    <div id="video-container">
        <video class="input_video"></video>
    </div>

    <div class="controls">
        <div id="instruction">Esperando manos...</div>
        <small id="debug-info"></small>
    </div>

    <script>
        // --- CONFIGURACI칍N ---
        const PARTICLE_COUNT = 90000; // Aumentado para mayor densidad
        
        // --- VARIABLES GLOBALES ---
        let scene, camera, renderer, particles, geometry, material;
        let positions, velocities, initialPositions;
        
        // Variables de Estado del Hechizo
        let currentStep = 0; 
        // 0: Esperando manos juntas (Prayer)
        // 1: Separando verticalmente (Creando Vara)
        // 2: Vara lista, esperando Pinch para rotar
            // 3: Rotando (Creando C칤rculos)
        // 4: Regresando al centro (Creando Rect치ngulos internos)
        // 5: Separando horizontalmente (Creando Cuadrado y Rayos)
        // 6: Cuadrado listo, esperando rotaci칩n de manos
        // 7: Rotando cuadrado (Estrella final y c칤rculos peque침os)
        // 8: Completo

        // Variables de Animaci칩n (Valores actuales interpolados)
        let animValues = {
            staffHeight: 0,      // Altura de la vara central
            staffAngle: 0,       // Rotaci칩n de la vara (0 = Vertical)
            circleProgress: 0,   // Cu치nto del c칤rculo se ha dibujado (0 a PI*2)
            innerRectAlpha: 0,   // Opacidad de rect치ngulos internos
            squareWidth: 0,      // Ancho del cuadrado (expansion horizontal)
            outerRaysAlpha: 0,   // Opacidad de rayos externos
            squareRotation: 0,   // Rotaci칩n del segundo cuadrado
            finalCirclesAlpha: 0, // Opacidad de los 4 c칤rculos finales
            startAngle: 0        // 츼ngulo inicial al comenzar la rotaci칩n
        };

        // Datos de manos
        let hand1 = new THREE.Vector3(0,0,0); // Izquierda (visual)
        let hand2 = new THREE.Vector3(0,0,0); // Derecha (visual)
        let isHandDetected = false;
        let isPinching = false;
        let time = 0;

        // Elementos DOM
        const loadingEl = document.getElementById('loading');
        const videoElement = document.getElementsByClassName('input_video')[0];
        const videoContainer = document.getElementById('video-container');
        const instructionEl = document.getElementById('instruction');
        const debugEl = document.getElementById('debug-info');

        // --- INICIALIZACI칍N THREE.JS ---
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.0002); // Niebla m칤nima para m치xima visibilidad

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.z = 600;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.lookAt(0, 0, 0); // Forzar a la c치mara a mirar al centro exacto (0,0,0)
            document.body.appendChild(renderer.domElement);

            // Crear Part칤culas
            createParticles();

            // Eventos
            window.addEventListener('resize', onWindowResize);
            
            // Iniciar Loop
            animate();
        }

        // --- SISTEMA DE PART칈CULAS ---
        function createParticles() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            
            // Atributo personalizado para saber a qu칠 parte del escudo pertenece la part칤cula
            // 0: Vara Central
            // 1: C칤rculo Interno
            // 2: C칤rculo Externo
            // 3: Rect치ngulos Internos
            // 4: Cuadrado Base
            // 5: Cuadrado Rotado
            // 6: Rayos Externos
            // 7: C칤rculos Finales
            // 8: Marcador Mano Izquierda
            // 9: Marcador Mano Derecha
            // 10: N칰cleo Central (Debug/Referencia)
            const shapeIds = new Float32Array(PARTICLE_COUNT);
            
            // Distribuci칩n de part칤culas
            let idx = 0;
            
            // Helper para asignar rangos
            const assignRange = (count, id) => {
                for(let i=0; i<count; i++) {
                    if(idx >= PARTICLE_COUNT) break;
                    shapeIds[idx] = id;
                    // Posici칩n inicial fuera de pantalla para que no moleste
                    positions[idx*3] = 9999;
                    positions[idx*3+1] = 9999;
                    positions[idx*3+2] = 0;
                    idx++;
                }
            };

            assignRange(8000, 0);  // Vara (M치s densa)
            assignRange(10000, 1); // C칤rculo Interno
            assignRange(15000, 2); // C칤rculo Externo
            assignRange(10000, 3); // Rect치ngulos Internos
            assignRange(10000, 4); // Cuadrado Base
            assignRange(10000, 5); // Cuadrado Rotado
            assignRange(10000, 6); // Rayos Externos
            assignRange(10000, 7); // C칤rculos Finales
            assignRange(2500, 8);  // Marcador Mano 1
            assignRange(2500, 9);  // Marcador Mano 2
            assignRange(1000, 10); // N칰cleo Central

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
            geometry.userData = { shapeIds: shapeIds };

            // Shader Material personalizado para mejor rendimiento y efectos visuales
            const vertexShader = `
                attribute vec3 color;
                varying vec3 vColor;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = (8000.0 / -mvPosition.z); // Puntos gigantes para que la vara se vea s칩lida
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;

            const fragmentShader = `
                varying vec3 vColor;
                void main() {
                    float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                    if (r > 0.5) discard;
                    float glow = 1.0 - (r * 2.0);
                    glow = pow(glow, 2.0);
                    gl_FragColor = vec4(vColor, glow);
                }
            `;

            material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- F칈SICA Y ANIMACI칍N ---
        function updateParticles() {
            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;
            const shapeIds = geometry.userData.shapeIds;
            const positions = posAttr.array; // Usar referencia directa para asegurar actualizaci칩n
            const colors = colAttr.array;
            
            // Colores Ne칩n
            const colorCenter = new THREE.Color(1.0, 1.0, 0.4); // Amarillo luminoso
            const colorEdge = new THREE.Color(1.0, 0.2, 0.0);   // Naranja/Rojo
            const colorHand1 = new THREE.Color(0.0, 0.5, 1.0);  // AZUL (Mano 1)
            const colorHand2 = new THREE.Color(1.0, 0.0, 0.2);  // ROJO (Mano 2)
            
            // Constantes de dimensiones
            const INNER_RADIUS = 180;
            const OUTER_RADIUS = 280;
            const MAX_HEIGHT = 300;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const id = shapeIds[i];
                
                // Variables temporales para posici칩n
                let px = 0, py = 0, pz = 0;
                let visible = false;
                let noise = (Math.random() - 0.5) * 5.0; 
                let isHandMarker = false;

                // --- L칍GICA DE FORMAS ---
                
                // 0: VARA CENTRAL (Staff)
                if (id === 0) {
                    if (animValues.staffHeight > 1) {
                        visible = true;
                        // Distribuir a lo largo de la altura (-h/2 a +h/2)
                        const h = animValues.staffHeight;
                        const t = (i % 8000) / 8000.0; // 0 a 1
                        const yLocal = (t - 0.5) * h; // Centrado verticalmente en 0 (mitad de pantalla)
                        
                        // A침adir grosor a la vara
                        const thickness = 25.0; // Vara muy gruesa para que sea imposible no verla
                        const xLocal = (Math.random() - 0.5) * thickness;

                        // Rotar la vara seg칰n staffAngle
                        const cosR = Math.cos(animValues.staffAngle);
                        const sinR = Math.sin(animValues.staffAngle);
                        
                        px = (xLocal * cosR - yLocal * sinR) + noise;
                        py = (xLocal * sinR + yLocal * cosR) + noise;
                        pz = (Math.random() - 0.5) * 5;
                    }
                }
                
                // 1 & 2: C칈RCULOS (Inner & Outer)
                else if (id === 1 || id === 2) {
                    const radius = (id === 1) ? INNER_RADIUS : OUTER_RADIUS;
                    const count = (id === 1) ? 10000 : 15000;
                    const t = (i % count) / count; // 0 a 1 (Progreso angular)
                    const angle = t * Math.PI * 2; // 0 a 360
                    
                    // Solo dibujar si el 치ngulo est치 dentro del progreso actual de rotaci칩n
                    // L칩gica de rastro simplificada:
                    // La vara empieza en 0 (vertical). Gira hasta PI (invertido).
                    // Mostramos el arco desde 0 hasta el 치ngulo actual (y su espejo)
                    
                    let currentRot = Math.abs(animValues.staffAngle);
                    // Normalizar para comparaci칩n (0 a PI)
                    if (currentRot > Math.PI) currentRot -= Math.PI;
                    
                    // Si ya completamos el paso 3, mostramos todo el c칤rculo
                    if (currentStep > 3) {
                        visible = true;
                    } else if (currentStep === 3) {
                        // Durante la rotaci칩n, mostrar si el 치ngulo de la part칤cula es menor al 치ngulo actual
                        // Ajustamos para que dibuje en ambos lados (simetr칤a central)
                        // Mapear 치ngulo de part칤cula a 0-PI (simetr칤a)
                        let pAngle = angle % Math.PI; // 0 a PI
                        
                        // Ajuste de fase: La vara empieza vertical (PI/2 en coordenadas polares est치ndar)
                        // Pero nuestro staffAngle es 0 para vertical.
                        // Simplificaci칩n visual: Mostrar todo lo que est칠 "detr치s" del barrido
                        // Barrido visual aproximado:
                        if (animValues.circleProgress > 0.1) {
                             // Mostrar aleatoriamente para efecto de construcci칩n
                             if (Math.random() < animValues.circleProgress) visible = true;
                        }
                    }

                    if (visible) {
                        px = radius * Math.cos(angle) + noise;
                        py = radius * Math.sin(angle) + noise;
                        pz = (Math.random() - 0.5) * 2;
                    }
                }

                // 3: RECT츼NGULOS INTERNOS
                else if (id === 3) {
                    if (animValues.innerRectAlpha > 0.01) {
                        visible = true;
                        // 3 rect치ngulos: 0, 45, 90 grados
                        const subGroup = i % 3;
                        const t = (i % 100) / 100.0; // A lo largo del per칤metro
                        
                        let w = INNER_RADIUS * 0.7; // Tama침o relativo al c칤rculo interno
                        let h = INNER_RADIUS * 0.4;
                        
                        // Generar puntos en per칤metro de rect치ngulo
                        // Simplificado: L칤neas aleatorias dentro de la caja rotada
                        let lx = (Math.random() - 0.5) * 2 * w;
                        let ly = (Math.random() - 0.5) * 2 * h;
                        
                        // Forzar a bordes para que parezca un rect치ngulo hueco
                        if (Math.random() > 0.5) {
                            lx = (Math.random() > 0.5 ? 1 : -1) * w;
                        } else {
                            ly = (Math.random() > 0.5 ? 1 : -1) * h;
                        }

                        let rot = 0;
                        if (subGroup === 1) rot = Math.PI / 4; // 45
                        if (subGroup === 2) rot = Math.PI / 2; // 90

                        px = lx * Math.cos(rot) - ly * Math.sin(rot) + noise;
                        py = lx * Math.sin(rot) + ly * Math.cos(rot) + noise;
                        pz = 0;
                    }
                }

                // 4 & 5: CUADRADOS (Base y Rotado)
                else if (id === 4 || id === 5) {
                    if (animValues.squareWidth > 10) {
                        visible = true;
                        // Cuadrado formado por la expansi칩n de la vara
                        // Alto fijo (MAX_HEIGHT), Ancho variable (animValues.squareWidth)
                        
                        let w = animValues.squareWidth;
                        let h = MAX_HEIGHT; // La altura de la vara original
                        
                        // Puntos en el per칤metro
                        let lx, ly;
                        if (Math.random() > 0.5) {
                            lx = (Math.random() - 0.5) * 2 * w;
                            ly = (Math.random() > 0.5 ? 1 : -1) * h;
                        } else {
                            lx = (Math.random() > 0.5 ? 1 : -1) * w;
                            ly = (Math.random() - 0.5) * 2 * h;
                        }

                        // Rotaci칩n base (si es el cuadrado 2)
                        let rot = 0;
                        if (id === 5) {
                            rot = animValues.squareRotation; // Gira din치micamente
                        }

                        px = lx * Math.cos(rot) - ly * Math.sin(rot) + noise;
                        py = lx * Math.sin(rot) + ly * Math.cos(rot) + noise;
                        pz = 0;
                    }
                }

                // 6: RAYOS EXTERNOS
                else if (id === 6) {
                    if (animValues.outerRaysAlpha > 0.01) {
                        visible = true;
                        // Rayos desde borde inner a borde outer
                        // No tocar zona inner
                        const angle = (Math.random() * Math.PI * 2);
                        // Radio entre Inner y Outer
                        const r = INNER_RADIUS + Math.random() * (OUTER_RADIUS - INNER_RADIUS);
                        
                        px = r * Math.cos(angle);
                        py = r * Math.sin(angle);
                        pz = 0;
                    }
                }

                // 7: C칈RCULOS FINALES
                else if (id === 7) {
                    if (animValues.finalCirclesAlpha > 0.01) {
                        visible = true;
                        // 4 c칤rculos en los puntos medios del cuadrado base (id 4)
                        // Puntos medios: (0, H), (0, -H), (W, 0), (-W, 0)
                        // Usamos el ancho final del cuadrado que debe ser igual al alto
                        const size = MAX_HEIGHT; 
                        const subGroup = i % 4;
                        let cx = 0, cy = 0;
                        
                        if (subGroup === 0) cy = size;
                        if (subGroup === 1) cy = -size;
                        if (subGroup === 2) cx = size;
                        if (subGroup === 3) cx = -size;

                        const rSmall = 30;
                        const angle = Math.random() * Math.PI * 2;
                        
                        px = cx + rSmall * Math.cos(angle) + noise;
                        py = cy + rSmall * Math.sin(angle) + noise;
                        pz = 0;
                    }
                }

                // 8 & 9: MARCADORES DE MANOS (Siempre visibles si hay detecci칩n)
                else if (id === 8 || id === 9) {
                    if (isHandDetected) {
                        visible = true;
                        isHandMarker = true;
                        const target = (id === 8) ? hand1 : hand2;
                        
                        // Esfera de energ칤a alrededor de la mano
                        const r = 20 * Math.random(); // Radio de la energ칤a de la mano
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        
                        px = target.x + r * Math.sin(phi) * Math.cos(theta);
                        py = target.y + r * Math.sin(phi) * Math.sin(theta);
                        pz = target.z + r * Math.cos(phi);
                    }
                }

                // 10: N칔CLEO CENTRAL (Siempre visible para referencia)
                else if (id === 10) {
                    visible = true;
                    // Latido en el centro (0,0) para marcar el origen exacto
                    const pulse = 1.0 + Math.sin(time * 8.0) * 0.3;
                    const r = 20 * Math.random() * pulse;
                    const theta = Math.random() * Math.PI * 2;
                    px = r * Math.cos(theta);
                    py = r * Math.sin(theta);
                    pz = (Math.random() - 0.5) * 5;
                }

                // --- APLICAR POSICI칍N Y COLOR ---
                if (visible) {
                    positions[ix] = px;
                    positions[ix+1] = py;
                    positions[ix+2] = pz;

                    // Color basado en distancia al centro (Amarillo -> Rojo)
                    const dist = Math.sqrt(px*px + py*py);
                    const tColor = Math.min(1.0, dist / 350.0);
                    let c;
                    if (isHandMarker) {
                        c = (id === 8) ? colorHand1 : colorHand2; // Diferenciar manos por color
                    } else {
                        c = colorCenter.clone().lerp(colorEdge, tColor);
                    }
                    
                    // Alpha global por grupo
                    let alpha = 1.0;
                    if (id === 3) alpha = animValues.innerRectAlpha;
                    if (id === 6) alpha = animValues.outerRaysAlpha;
                    if (id === 7) alpha = animValues.finalCirclesAlpha;

                    colors[ix] = c.r * alpha;
                    colors[ix+1] = c.g * alpha;
                    colors[ix+2] = c.b * alpha;
                } else {
                    // Ocultar lejos
                    positions[ix] = 9999;
                }
            }

            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // L칩gica de la M치quina de Estados
            updateSpellLogic();

            updateParticles();
            renderer.render(scene, camera);
        }

        // --- L칍GICA DEL HECHIZO (STATE MACHINE) ---
        function updateSpellLogic() {
            if (!isHandDetected) {
                instructionEl.innerHTML = "Coloca ambas manos frente a la c치mara";
                return;
            }

            const dist = hand1.distanceTo(hand2);
            const dy = Math.abs(hand1.y - hand2.y);
            const dx = Math.abs(hand1.x - hand2.x);
            
            // Vector entre manos para calcular 치ngulo
            const diff = new THREE.Vector3().subVectors(hand2, hand1);
            const angle = Math.atan2(diff.y, diff.x); // -PI a PI

            let msg = "";

            // STEP 0: PRAYER (Manos juntas)
            if (currentStep === 0) {
                msg = "1) Junta las manos (游똂)";
                if (dist < 180) { // Muy tolerante
                    currentStep = 1;
                }
            }
            
            // STEP 1: SEPARAR VERTICALMENTE (Vara)
            else if (currentStep === 1) {
                msg = "2) Separa una mano arriba y otra abajo";
                // Mapear distancia vertical a altura de vara
                // Max height deseada ~300
                let targetH = Math.min(600, dy * 2.5); // Altura m치xima aumentada (600 = pantalla completa vert)
                animValues.staffHeight += (targetH - animValues.staffHeight) * 0.1;

                if (animValues.staffHeight > 250) { 
                    currentStep = 2;
                    animValues.staffHeight = 600; // Fijar altura m치xima para que no se encoja
                }
            }

            // STEP 2: PREPARAR ROTACI칍N (Pellizco)
            else if (currentStep === 2) {
                msg = "3) Haz gesto de pellizco (游밾) y rota las manos 180춿";
                if (isPinching) {
                    currentStep = 3;
                    // Guardar 치ngulo exacto donde empezamos para medir el progreso relativo
                    animValues.startAngle = angle;
                }
            }

            // STEP 3: ROTACI칍N (Crear C칤rculos)
            else if (currentStep === 3) {
                msg = "Gira las manos 180춿 (como las agujas del reloj)";
                
                // 1. Calcular cu치nto hemos girado desde el inicio (Delta)
                let delta = angle - animValues.startAngle;
                
                // Normalizar delta para manejar el salto de PI a -PI
                while (delta <= -Math.PI) delta += Math.PI*2;
                while (delta > Math.PI) delta -= Math.PI*2;
                
                // 2. Progreso: 0 a PI (180 grados)
                // Usamos valor absoluto para permitir giro izquierda o derecha
                let progress = Math.abs(delta) / Math.PI; 
                
                // Actualizar visuales
                animValues.circleProgress = Math.min(1.0, progress);
                animValues.staffAngle = delta; 

                // 3. Condici칩n de salida: Completar 180 grados (aprox 90% del camino)
                if (progress > 0.9) {
                    currentStep = 4;
                    animValues.circleProgress = 1.0; // Asegurar c칤rculo completo
                    animValues.staffAngle = 0; // Reset visual
                }
            }

            // STEP 4: REGRESAR AL CENTRO (Rect치ngulos)
            else if (currentStep === 4) {
                msg = "4) Junta las manos al centro de nuevo";
                
                // Rect치ngulos aparecen mientras manos se acercan
                // Distancia va de 300 a 0. Alpha va de 0 a 1.
                let progress = 1.0 - (dist / 300.0);
                animValues.innerRectAlpha = Math.max(0, Math.min(1, progress));

                if (dist < 60) {
                    currentStep = 5;
                    animValues.innerRectAlpha = 1; // Asegurar visible
                }
            }

            // STEP 5: SEPARAR HORIZONTAL (Cuadrado)
            else if (currentStep === 5) {
                msg = "5) Separa las manos hacia los lados (Izquierda/Derecha)";
                // Mapear dx a squareWidth
                let targetW = Math.min(300, dx * 1.2); // 300 es el alto (MAX_HEIGHT)
                animValues.squareWidth += (targetW - animValues.squareWidth) * 0.1;
                
                // Rayos externos aparecen
                animValues.outerRaysAlpha = Math.min(1, animValues.squareWidth / 200.0);

                if (animValues.squareWidth > 280) {
                    currentStep = 6;
                }
            }

            // STEP 6: ROTAR MANOS (Estrella)
            else if (currentStep === 6) {
                msg = "6) Gira las manos 45춿";
                // Detectar rotaci칩n de mu침eca es dif칤cil con solo puntos, 
                // usamos la inclinaci칩n del vector entre 칤ndice y mu침eca o simplemente la inclinaci칩n general
                // Si el usuario inclina las manos, el vector diff (dx, dy) cambia de ser horizontal puro
                
                // Si dy aumenta sin que dx disminuya mucho (rotaci칩n sobre eje Z)
                // O simplemente usamos el 치ngulo de nuevo
                let rot = Math.abs(angle); // 0 es horizontal
                if (rot > 0.5) { // ~30 grados
                    let targetRot = Math.PI / 4; // 45 grados
                    animValues.squareRotation += (targetRot - animValues.squareRotation) * 0.1;
                    
                    if (animValues.squareRotation > 0.7) {
                        currentStep = 7;
                    }
                }
            }

            // STEP 7: FINAL
            else if (currentStep === 7) {
                msg = "춰HECHIZO COMPLETO!";
                animValues.finalCirclesAlpha += 0.05;
                if (animValues.finalCirclesAlpha > 1) animValues.finalCirclesAlpha = 1;
            }

            instructionEl.innerHTML = msg;
            debugEl.innerHTML = `Paso: ${currentStep} | Sep: ${Math.round(dy)} | Altura Vara: ${Math.round(animValues.staffHeight)}`;
        }

        // --- MEDIAPIPE HANDS ---
        function onResults(results) {
            loadingEl.style.display = 'none';
            videoContainer.style.display = 'block';

            const handsDetected = results.multiHandLandmarks.length;
            const wasHandDetected = isHandDetected; // Guardar estado anterior

            if (handsDetected > 0) {
                isHandDetected = true;
                
                // Helper para obtener posici칩n
                const getPos = (landmarks, index) => {
                    return new THREE.Vector3(
                        (0.5 - landmarks[index].x) * window.innerWidth,
                        (0.5 - landmarks[index].y) * window.innerHeight,
                        0
                    );
                };

                // Detectar Pinch (Pulgar 4 e 칈ndice 8 cerca)
                const checkPinch = (landmarks) => {
                    const p1 = getPos(landmarks, 4);
                    const p2 = getPos(landmarks, 8);
                    return p1.distanceTo(p2) < 40;
                };

                let h1, h2;

                if (handsDetected === 2) {
                    // Nuevas posiciones detectadas
                    const hA = getPos(results.multiHandLandmarks[0], 9);
                    const hB = getPos(results.multiHandLandmarks[1], 9);
                    
                    // TRACKING INTELIGENTE:
                    // Si ya ten칤amos manos detectadas, asignamos las nuevas a las m치s cercanas (por distancia)
                    // Esto evita que se intercambien (Azul/Rojo) cuando se cruzan o giran.
                    if (wasHandDetected) {
                        const distA1 = hand1.distanceTo(hA);
                        const distA2 = hand1.distanceTo(hB);
                        
                        if (distA1 < distA2) {
                            hand1.lerp(hA, 0.5);
                            hand2.lerp(hB, 0.5);
                            isPinching = checkPinch(results.multiHandLandmarks[0]) && checkPinch(results.multiHandLandmarks[1]);
                        } else {
                            hand1.lerp(hB, 0.5);
                            hand2.lerp(hA, 0.5);
                            isPinching = checkPinch(results.multiHandLandmarks[1]) && checkPinch(results.multiHandLandmarks[0]);
                        }
                    } else {
                        // Primera detecci칩n: Ordenar por X para inicializar (Izq=Azul, Der=Rojo)
                        if (hA.x < hB.x) {
                            hand1.copy(hA); hand2.copy(hB);
                        } else {
                            hand1.copy(hB); hand2.copy(hA);
                        }
                        isPinching = checkPinch(results.multiHandLandmarks[0]) && checkPinch(results.multiHandLandmarks[1]);
                    }
                } else {
                    // Una mano (Modo espejo para pruebas)
                    h1 = getPos(results.multiHandLandmarks[0], 9);
                    // La segunda mano es el espejo de la primera respecto al centro (0,0)
                    // Como las coordenadas de Three.js est치n centradas si la c치mara est치 en 0,0,z
                    // Pero aqu칤 getPos devuelve coords de pantalla. Ajustamos:
                    // Asumimos centro pantalla es 0,0 para l칩gica
                    
                    hand2.copy(h1); // Mano derecha sigue a la real
                    hand1.copy(h1).multiplyScalar(-1); // Mano izquierda es espejo
                    // Ajuste visual simple:
                    hand2.x = h1.x; hand2.y = h1.y;
                    hand1.x = -h1.x; hand1.y = h1.y; // Espejo en X
                    
                    isPinching = checkPinch(results.multiHandLandmarks[0]);
                }
                
            } else {
                isHandDetected = false;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Configurar c치mara
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        // Funci칩n para solicitar permiso de c치mara expl칤citamente (Estilo Meet)
        async function requestCameraAccess() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                loadingEl.innerHTML = "Error: Tu navegador no soporta acceso a la c치mara.";
                return;
            }

            try {
                // 1. Solicitar permiso expl칤citamente al navegador
                // Esto har치 aparecer el popup nativo de "Permitir c치mara"
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                
                // 2. Si el usuario acepta, detenemos este stream temporal (MediaPipe usar치 el suyo)
                stream.getTracks().forEach(track => track.stop());
                
                // 3. Iniciamos la librer칤a de MediaPipe
                await cameraUtils.start();
            } catch (err) {
                console.error("Permiso denegado:", err);
                loadingEl.innerHTML = "丘멆잺 <strong>Permiso requerido</strong><br>Por favor permite el acceso a la c치mara en la barra de direcci칩n y recarga la p치gina.";
                loadingEl.style.color = "#ff5555";
                loadingEl.style.borderColor = "#ff5555";
            }
        }

        // Iniciar solicitud
        requestCameraAccess();

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Arrancar Three.js
        initThree();

    </script>
</body>
</html>