<!-- /workspaces/mano-control/gato.html -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dibujar Gato Con Las Manos</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ccff;
            font-size: 24px;
            text-align: center;
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 1px solid #00ccff;
            border-radius: 8px;
            transition: opacity 0.5s;
        }
        #video-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 160px;
            height: 120px;
            z-index: 5;
            opacity: 0.7;
            border: 1px solid #333;
            transform: scaleX(-1); /* Efecto espejo */
            display: block; /* Mostrar siempre para facilitar ubicaci칩n */
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 350px;
            border: 1px solid #444;
        }
        #instruction {
            font-weight: bold;
            color: #00ccff;
            margin-bottom: 5px;
            font-size: 16px;
        }
    </style>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        Para empezar necesitamos acceso a tu c치mara...<br>
        <small>Por favor permite el acceso a la c치mara</small>
    </div>

    <div id="video-container">
        <video class="input_video"></video>
    </div>

    <div class="controls">
        <div id="instruction">Esperando manos...</div>
        <small id="debug-info" style="color: #aaa;"></small>
    </div>

    <script>
        // --- CONFIGURACI칍N ---
        const PARTICLE_COUNT = 60000;
        
        // --- VARIABLES GLOBALES ---
        let scene, camera, renderer, particles, geometry, material;
        let positions, colors;
        let catPlane; // Imagen del gato real
        
        // Estado del Gato
        let currentStep = 0; 
        // 0: Inicio (Esperando)
        // 1: Cara (C칤rculo)
        // 2: Orejas (Tri치ngulos)
        // 3: Cuerpo (칍valo)
        // 4: Cola (Curva interactiva)
        // 5: Bigotes (L칤neas)
        // 6: Vida (Detalles finales + Latido)

        // Animaci칩n y Transiciones
        let anim = {
            faceAlpha: 0,
            earsAlpha: 0,
            bodyAlpha: 0,
            tailAlpha: 0,
            whiskersAlpha: 0,
            detailsAlpha: 0,
            tailTip: new THREE.Vector3(150, -150, 0), // Posici칩n punta de cola
            lifePulse: 0,
            pushEffect: 0, // Efecto de explosi칩n al dar vida
            tailWag: 0 // Movimiento de la cola
        };

        // Datos de manos
        let hand1 = new THREE.Vector3(0,0,0);
        let hand2 = new THREE.Vector3(0,0,0);
        let handSize = 0; // Para detectar el "empuj칩n" (acercamiento)
        let prevHandSize = 0;
        let isHandDetected = false;
        let handsDetectedCount = 0;
        let isPinchingLeft = false;
        let isPinchingRight = false;
        let fingers = { left: [], right: [] }; // Estado de dedos
        let time = 0;

        // Elementos DOM
        const loadingEl = document.getElementById('loading');
        const videoElement = document.getElementsByClassName('input_video')[0];
        const videoContainer = document.getElementById('video-container');
        const instructionEl = document.getElementById('instruction');
        const debugEl = document.getElementById('debug-info');

        // --- INICIALIZACI칍N THREE.JS ---
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.001);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.z = 600;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            createParticles();
            createRealCat();
            window.addEventListener('resize', onWindowResize);
            camera.lookAt(0, 0, 0);
            animate();
        }

        // --- SISTEMA DE PART칈CULAS ---
        function createParticles() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            colors = new Float32Array(PARTICLE_COUNT * 3);
            const shapeIds = new Float32Array(PARTICLE_COUNT);
            const randoms = new Float32Array(PARTICLE_COUNT); // Para variaciones

            let idx = 0;
            const assignRange = (count, id) => {
                for(let i=0; i<count; i++) {
                    if(idx >= PARTICLE_COUNT) break;
                    shapeIds[idx] = id;
                    randoms[idx] = Math.random();
                    // Inicializar fuera
                    positions[idx*3] = 9999;
                    positions[idx*3+1] = 9999;
                    positions[idx*3+2] = 0;
                    idx++;
                }
            };

            // Distribuci칩n de part칤culas para las partes del gato
            assignRange(10000, 0); // Cara (C칤rculo)
            assignRange(5000, 1);  // Orejas
            assignRange(15000, 2); // Cuerpo (칍valo)
            assignRange(8000, 3);  // Cola
            assignRange(6000, 4);  // Bigotes
            assignRange(5000, 5);  // Detalles (Ojos, Nariz, Boca)
            assignRange(2000, 6);  // Manos (Gu칤a visual)
            assignRange(9000, 7);  // Aura / Relleno

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
            geometry.userData = { shapeIds: shapeIds, randoms: randoms };

            const vertexShader = `
                attribute vec3 color;
                varying vec3 vColor;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = (6000.0 / -mvPosition.z); // Aumentado para mejor visibilidad
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;

            const fragmentShader = `
                varying vec3 vColor;
                void main() {
                    float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                    if (r > 0.5) discard;
                    float glow = 1.0 - (r * 2.0);
                    glow = pow(glow, 2.0);
                    gl_FragColor = vec4(vColor, glow);
                }
            `;

            material = new THREE.ShaderMaterial({
                vertexShader, fragmentShader,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            particles.frustumCulled = false; // IMPORTANTE: Evita que desaparezcan al moverse
            scene.add(particles);
        }

        // --- CARGAR IMAGEN REAL ---
        function createRealCat() {
            const loader = new THREE.TextureLoader();
            loader.load('gato.png', (texture) => {
                const geometry = new THREE.PlaneGeometry(400, 450);
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true, 
                    opacity: 0.0,
                    depthWrite: false
                });
                catPlane = new THREE.Mesh(geometry, material);
                catPlane.position.set(0, 10, 5);
                scene.add(catPlane);
            });
        }

        // --- L칍GICA DE FORMAS Y ANIMACI칍N ---
        function updateParticles() {
            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;
            const shapeIds = geometry.userData.shapeIds;
            const randoms = geometry.userData.randoms;
            const pArr = posAttr.array;
            const cArr = colAttr.array;

            // Colores
            const cBlue = new THREE.Color(0x00ccff);
            const cPurple = new THREE.Color(0xaa00ff);
            const cWhite = new THREE.Color(0xffffff);
            const cGold = new THREE.Color(0xffaa00);

            // Par치metros Geom칠tricos
            const faceX = -40; // Ajustado a la imagen
            const faceY = 100; 
            const faceRad = 90;
            const bodyX = 30; // Ajustado a la imagen
            const bodyY = -80; 
            const bodyRadX = 100;
            const bodyRadY = 130;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const id = shapeIds[i];
                const rnd = randoms[i];
                
                let px = 0, py = 0, pz = 0;
                let visible = false;
                let alpha = 0;
                let color = cBlue;
                let noise = (Math.random() - 0.5) * 3;

                // --- 0: CARA (C칤rculo) ---
                if (id === 0) {
                    if (anim.faceAlpha > 0.01) {
                        visible = true;
                        alpha = anim.faceAlpha;
                        const angle = rnd * Math.PI * 2;
                        // Anillo grueso
                        const r = faceRad + (Math.random() - 0.5) * 10; 
                        px = faceX + r * Math.cos(angle);
                        py = faceY + r * Math.sin(angle);
                    }
                }

                // --- 1: OREJAS (Tri치ngulos) ---
                else if (id === 1) {
                    if (anim.earsAlpha > 0.01) {
                        visible = true;
                        alpha = anim.earsAlpha;
                        // Dos orejas
                        const isLeft = (i % 2 === 0); // Corregido: Desacoplar de rnd para evitar triangulo incompleto
                        const side = isLeft ? -1 : 1;
                        
                        // Base en el c칤rculo, punta hacia arriba
                        // Coordenadas locales de oreja
                        const t = (i % 100) / 100.0; // 0 a 1 a lo largo del tri치ngulo
                        // Simplificado: Puntos aleatorios dentro de un tri치ngulo
                        // A: Base externa, B: Base interna, C: Punta
                        const bx = faceX + side * (faceRad * 0.8);
                        const by = faceY + (faceRad * 0.5);
                        const tipX = faceX + side * (faceRad * 0.5);
                        const tipY = faceY + faceRad * 1.5;
                        
                        // Interpolaci칩n baric칠ntrica simple (o l칤neas)
                        const r1 = Math.random();
                        const r2 = Math.random();
                        if (r1 + r2 <= 1) {
                            // Dentro del tri치ngulo
                            px = bx + (tipX - bx) * r1 + (0 - 20 * side) * r2; // Aprox
                            // Mejor: Dibujar contorno
                            const edge = Math.floor(rnd * 3); // 0: ext, 1: int
                            if (edge === 0) { // Lado externo
                                px = bx + (tipX - bx) * t;
                                py = by + (tipY - by) * t;
                            } else { // Lado interno
                                const ix = faceX + side * (faceRad * 0.3);
                                const iy = faceY + (faceRad * 0.9);
                                px = tipX + (ix - tipX) * t;
                                py = tipY + (iy - tipY) * t;
                            }
                        }
                        px += noise; py += noise;
                    }
                }

                // --- 2: CUERPO (칍valo) ---
                else if (id === 2) {
                    if (anim.bodyAlpha > 0.01) {
                        visible = true;
                        alpha = anim.bodyAlpha;
                        
                        // Dividir part칤culas: 85% Cuerpo, 15% Patas
                        if (rnd < 0.85) {
                            // --- CUERPO PRINCIPAL ---
                            const angle = (rnd / 0.85) * Math.PI * 2;
                            const rX = bodyRadX + (Math.random()-0.5)*10;
                            const rY = bodyRadY + (Math.random()-0.5)*10;
                            
                            // Forma de pera (m치s ancho abajo) para coincidir con el gato sentado
                            let rawPx = rX * Math.cos(angle);
                            let rawPy = rY * Math.sin(angle);
                            let widthFactor = 1.0 - ((rawPy / rY) * 0.2 + 0.1); // Estrechar arriba
                            
                            px = bodyX + rawPx * widthFactor;
                            py = bodyY + rawPy;
                            
                            // Recortar parte superior donde conecta con cabeza para que no se superponga feo
                            if (py > faceY - 40) visible = false;
                        } else {
                            // --- PATAS DELANTERAS (Se forman con el cuerpo) ---
                            const subRnd = (rnd - 0.85) / 0.15; // Normalizar 0 a 1
                            const isLeft = subRnd > 0.5;
                            const pawSign = isLeft ? -1 : 1;
                            
                            // Posici칩n de las patas (abajo del cuerpo)
                            const pawCX = bodyX + pawSign * 40; 
                            const pawCY = bodyY - bodyRadY + 35; 
                            
                            const pAngle = subRnd * Math.PI * 10; // Relleno aleatorio
                            const prX = 28 + Math.random()*5; // Ancho pata
                            const prY = 18 + Math.random()*5; // Alto pata
                            
                            px = pawCX + prX * Math.cos(pAngle);
                            py = pawCY + prY * Math.sin(pAngle);
                        }
                    }
                }

                // --- 3: COLA (Curva Bezier Interactiva) ---
                else if (id === 3) {
                    if (anim.tailAlpha > 0.01) {
                        visible = true;
                        alpha = anim.tailAlpha;
                        
                        // Origen: Base del cuerpo (lado derecho o izquierdo seg칰n mano)
                        // Usamos anim.tailTip como destino
                        const startX = bodyX + 70; // Cola sale del lado derecho
                        const startY = bodyY - bodyRadY + 20;
                        
                        const endX = anim.tailTip.x;
                        const endY = anim.tailTip.y;
                        
                        // Punto de control para curva (S-shape)
                        const cpX = (startX + endX) / 2 + anim.tailWag;
                        const cpY = Math.min(startY, endY) - 50;

                        const t = (i % 1000) / 1000.0; // Progreso en curva
                        
                        // Curva Cuadr치tica Bezier
                        const invT = 1 - t;
                        px = invT*invT*startX + 2*invT*t*cpX + t*t*endX;
                        py = invT*invT*startY + 2*invT*t*cpY + t*t*endY;
                        
                        px += (Math.random()-0.5) * 15; // Grosor peludo
                        py += (Math.random()-0.5) * 15;
                    }
                }

                // --- 4: BIGOTES (L칤neas) ---
                else if (id === 4) {
                    if (anim.whiskersAlpha > 0.01) {
                        visible = true;
                        alpha = anim.whiskersAlpha;
                        
                        const isLeft = rnd > 0.5;
                        const side = isLeft ? -1 : 1;
                        const whiskerIdx = Math.floor(rnd * 10) % 3; // 3 bigotes por lado
                        
                        const startX = faceX + side * 20;
                        const startY = faceY - 10;
                        
                        // 츼ngulos: 0, 15, -15 grados
                        let ang = (whiskerIdx - 1) * 0.3;
                        if (isLeft) ang = Math.PI - ang;
                        
                        const len = 120;
                        const t = (i % 100) / 100.0;
                        
                        px = startX + Math.cos(ang) * len * t;
                        py = startY + Math.sin(ang) * len * t;
                        
                        // Movimiento sutil "respiraci칩n"
                        py += Math.sin(time * 5 + whiskerIdx) * 2 * t;
                    }
                }

                // --- 5: DETALLES (Ojos, Nariz, Boca) ---
                else if (id === 5) {
                    if (anim.detailsAlpha > 0.01) {
                        visible = true;
                        alpha = anim.detailsAlpha;
                        color = cGold; // Ojos brillantes
                        
                        const part = Math.floor(rnd * 10); // Subdividir
                        
                        if (part < 4) { // Ojos
                            const isLeft = part < 2;
                            const ex = faceX + (isLeft ? -35 : 35);
                            const ey = faceY + 10;
                            // Forma de ojo (elipse peque침a)
                            const ang = rnd * Math.PI * 2;
                            px = ex + 12 * Math.cos(ang);
                            py = ey + 8 * Math.sin(ang);
                            // Pupila vertical (gato)
                            if (Math.random() > 0.8) {
                                px = ex + (Math.random()-0.5)*2;
                                py = ey + (Math.random()-0.5)*12;
                                color = new THREE.Color(0x000000); // Pupila negra (simulada por contraste o hueco)
                            }
                        } else if (part < 7) { // Nariz
                            const nx = faceX;
                            const ny = faceY - 15;
                            // Tri치ngulo invertido peque침o
                            px = nx + (Math.random()-0.5)*15;
                            py = ny + (Math.random()-0.5)*10;
                            color = new THREE.Color(0xffaaaa); // Rosado
                        } else { // Boca
                            // W shape
                            const t = rnd; // 0 a 1
                            const bx = faceX + (t - 0.5) * 40;
                            const by = faceY - 35 + Math.abs(Math.sin(t * Math.PI * 2)) * 5;
                            px = bx; py = by;
                        }
                    }
                }

                // --- 6: MARCADORES DE MANOS ---
                else if (id === 6) {
                    if (isHandDetected) {
                        visible = true;
                        alpha = 0.5;
                        const target = (i % 2 === 0) ? hand1 : hand2;
                        px = target.x + noise * 5;
                        py = target.y + noise * 5;
                        pz = target.z;
                    }
                }

                // --- 7: AURA / AMBIENTE (Siempre visible) ---
                else if (id === 7) {
                    visible = true;
                    alpha = 0.2 + Math.sin(time * 0.5 + i) * 0.1;
                    color = cPurple;
                    
                    // Movimiento flotante suave
                    const theta = rnd * Math.PI * 2;
                    const r = 300 + Math.sin(time * 0.2 + rnd * 10) * 50;
                    px = r * Math.cos(theta);
                    py = r * Math.sin(theta) * 0.8; // M치s achatado
                    pz = (randoms[(i+1)%PARTICLE_COUNT] - 0.5) * 200;
                }

                // --- EFECTO DE VIDA (PUSH) ---
                if (anim.pushEffect > 0) {
                    // Explosi칩n radial desde el centro
                    const dist = Math.sqrt(px*px + py*py);
                    const dirX = px / (dist+0.1);
                    const dirY = py / (dist+0.1);
                    
                    const blast = anim.pushEffect * 50.0 * rnd;
                    px += dirX * blast;
                    py += dirY * blast;
                    pz += blast * 2.0; // Hacia la c치mara
                    
                    // Brillo intenso
                    if (visible) alpha = 1.0;
                }

                // Asignar
                if (visible) {
                    pArr[ix] = px;
                    pArr[ix+1] = py;
                    pArr[ix+2] = pz;
                    
                    // Mezclar color base con blanco seg칰n "vida"
                    const finalC = color.clone().lerp(cWhite, anim.pushEffect);
                    
                    // Desvanecer part칤culas si aparece el gato real
                    let fade = 1.0;
                    if (catPlane && catPlane.material.opacity > 0) {
                        fade = 1.0 - catPlane.material.opacity * 0.8;
                    }

                    cArr[ix] = finalC.r * alpha * fade;
                    cArr[ix+1] = finalC.g * alpha * fade;
                    cArr[ix+2] = finalC.b * alpha * fade;
                } else {
                    pArr[ix] = 9999;
                }
            }

            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            updateSpellLogic();
            updateParticles();
            
            // Efecto de latido final
            if (currentStep === 6) {
                const scale = 1.0 + Math.sin(time * 4) * 0.02;
                scene.scale.set(scale, scale, scale);
            }

            renderer.render(scene, camera);
        }

        // --- L칍GICA DEL HECHIZO (STATE MACHINE) ---
        function updateSpellLogic() {
            if (!isHandDetected) {
                instructionEl.innerHTML = "Coloca ambas manos frente a la c치mara";
                return;
            }

            const dist = hand1.distanceTo(hand2);
            const dy = (hand1.y + hand2.y) / 2; // Altura promedio
            let msg = "";

            // --- GESTI칍N DE ESTADOS ---

            // STEP 0 -> 1: CARA (Juntar manos)
            if (currentStep === 0) {
                msg = "1) Pellizca con ambas manos (游녧) y j칰ntalas (Cara)";
                // Requiere pellizco y cercan칤a
                if (isPinchingLeft && isPinchingRight && dist < 200) {
                    currentStep = 1;
                }
            }
            
            // STEP 1 -> 2: OREJAS (Separar arriba)
            else if (currentStep === 1) {
                msg = "2) Separa las manos hacia ARRIBA (Orejas)"; 
                if (dist > 150 && dy > 50) {
                    currentStep = 2;
                }
            }

            // STEP 2 -> 3: CUERPO (Bajar manos)
            else if (currentStep === 2) {
                msg = "3) Pellizca y baja las manos para crear el CUERPO";
                
                // El cuerpo aparece a medida que bajas las manos (dy va de +100 a -100 aprox)
                if (isPinchingLeft && isPinchingRight) {
                    // Mapear posici칩n vertical a opacidad (Progreso)
                    // 100 (Arriba) -> 0.0 | -100 (Abajo) -> 1.0
                    let progress = (100 - dy) / 200;
                    anim.bodyAlpha = Math.max(0, Math.min(1, progress));

                    if (dy < -80) {
                        currentStep = 3;
                        anim.bodyAlpha = 1.0; // Asegurar completo
                    }
                }
            }

            // STEP 3 -> 4: COLA (Mover una mano al lado)
            else if (currentStep === 3) {
                msg = "4) Usa UNA mano: Pellizca para dibujar la cola. Suelta para terminar.";
                
                if (handsDetectedCount === 1) {
                    const isPinching = isPinchingLeft || isPinchingRight;
                    if (isPinching) {
                        // Dibujando: La cola aparece y sigue la mano
                        anim.tailAlpha = Math.min(1, anim.tailAlpha + 0.05);
                        
                        // La punta de la cola sigue a la mano activa
                        const activeHand = (Math.abs(hand1.x) > Math.abs(hand2.x)) ? hand1 : hand2;
                        anim.tailTip.lerp(activeHand, 0.2);
                    } else {
                        // Si soltamos el pellizco y ya se dibuj칩 algo, terminamos
                        if (anim.tailAlpha > 0.5) {
                             currentStep = 4;
                        }
                    }
                } else if (handsDetectedCount > 1) {
                    msg = "丘멆잺 춰Solo UNA mano para la cola!";
                }
                
                // Asegurar que no se mueva sola mientras se forma
                anim.tailWag = 0;
            }

            // --- L칍GICA DE COLA (Post-Formaci칩n) ---
            if (currentStep >= 4) {
                // Base de la cola (aproximada seg칰n bodyY y bodyRadY)
                const tailBase = new THREE.Vector3(100, -195, 0); // bodyX(30) + offset(70)
                let isControllingTail = false;

                // Si hay solo 1 mano y solo el dedo 칤ndice levantado
                if (handsDetectedCount === 1) {
                    // fingers.left es igual a fingers.right cuando hay 1 mano (por l칩gica de espejo en onResults)
                    const fList = fingers.left; 
                    const count = fList.filter(f => f).length;
                    const isIndexOnly = (count === 1 && fList[1]); // 칈ndice es el 칤ndice 1

                    if (isIndexOnly) {
                        isControllingTail = true;
                        // La cola sigue al dedo (hand1 es el centro, aproximamos)
                        const dir = new THREE.Vector3().subVectors(hand1, tailBase);
                        const len = dir.length();
                        const maxLen = 300; // Limitaci칩n de longitud
                        if (len > maxLen) dir.normalize().multiplyScalar(maxLen);
                        
                        const target = new THREE.Vector3().addVectors(tailBase, dir);
                        anim.tailTip.lerp(target, 0.1);
                        anim.tailWag = 0; // No se mueve sola si la controlas
                    }
                }

                if (!isControllingTail) {
                    // Movimiento aleatorio / libre
                    anim.tailWag = Math.sin(time * 3) * 50;
                }
            }

            // STEP 4 -> 5: BIGOTES (Gesto 3 dedos)
            else if (currentStep === 4) {
                msg = "5) Muestra las 2 manos y muestra 3 dedos y estira hacia afuera con los 3 dedos para hacer los bigotes";

                // Detectar gesto 3 dedos
                const countFingers = (fList) => fList.filter(f => f).length;
                const f1 = countFingers(fingers.left);
                const f2 = countFingers(fingers.right);
                
                // Relajamos la condici칩n: Al menos 3 dedos en cada mano (y que haya 2 manos)
                if (handsDetectedCount === 2 && f1 >= 3 && f2 >= 3) {
                    currentStep = 5;
                }
            }

            // STEP 5 -> 6: VIDA (Empuj칩n)
            else if (currentStep === 5) {
                msg = "6) 춰AC칄RCATE BRUSCAMENTE para darle VIDA!";
                
                const deltaSize = handSize - prevHandSize;
                if (deltaSize > 5.0) { 
                    currentStep = 6;
                }
            }

            // STEP 6: FINAL
            else if (currentStep === 6) {
                msg = "춰MIAU! El Gato M칤stico vive.";
                
                // Efecto de explosi칩n inicial
                if (anim.pushEffect < 1.0 && anim.detailsAlpha < 0.5) {
                    anim.pushEffect += 0.1;
                } else {
                    anim.pushEffect = Math.max(0, anim.pushEffect - 0.05);
                }

                // Aparecer gato real
                if (catPlane) {
                    catPlane.material.opacity = Math.min(1, catPlane.material.opacity + 0.05);
                }
            }

            // --- ACTUALIZACI칍N DE ANIMACIONES (Acumulativo) ---
            // Esto asegura que las partes anteriores sigan visibles y apareciendo
            if (currentStep >= 1) anim.faceAlpha = Math.min(1, anim.faceAlpha + 0.05);
            if (currentStep >= 2) anim.earsAlpha = Math.min(1, anim.earsAlpha + 0.05);
            if (currentStep >= 3) anim.bodyAlpha = Math.min(1, anim.bodyAlpha + 0.05); // Mantener visible despu칠s del paso 2
            if (currentStep >= 4) anim.tailAlpha = Math.min(1, anim.tailAlpha + 0.05); // Mantener visible despu칠s del paso 3
            if (currentStep >= 5) anim.whiskersAlpha = Math.min(1, anim.whiskersAlpha + 0.05);
            if (currentStep >= 6) anim.detailsAlpha = Math.min(1, anim.detailsAlpha + 0.05);

            instructionEl.innerHTML = msg;
            debugEl.innerHTML = `Paso: ${currentStep} | Dist: ${Math.round(dist)} | Dedos: ${fingers.left.filter(x=>x).length}/${fingers.right.filter(x=>x).length}`;
            
            prevHandSize = handSize;
        }

        // --- MEDIAPIPE HANDS ---
        function onResults(results) {
            loadingEl.style.display = 'none';
            videoContainer.style.display = 'block';

            handsDetectedCount = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                
                // Helper coordenadas
                const getPos = (landmarks, index) => {
                    return new THREE.Vector3(
                        (0.5 - landmarks[index].x) * window.innerWidth,
                        (0.5 - landmarks[index].y) * window.innerHeight,
                        0
                    );
                };

                // Helper dedos levantados (Punta vs Nudillo)
                const checkFingers = (lm) => {
                    // 0: Pulgar, 1: 칈ndice, 2: Medio, 3: Anular, 4: Me침ique
                    // 칈ndices de puntas: 4, 8, 12, 16, 20
                    // 칈ndices de nudillos base (MCP): 2, 5, 9, 13, 17
                    // Para pulgar es distinto (x vs x), para otros es y vs y
                    const open = [];
                    // Pulgar (eje X aprox)
                    open.push(Math.abs(lm[4].x - lm[0].x) > Math.abs(lm[3].x - lm[0].x)); 
                    // Otros (eje Y, invertido en MP, menor es m치s arriba)
                    open.push(lm[8].y < lm[6].y);
                    open.push(lm[12].y < lm[10].y);
                    open.push(lm[16].y < lm[14].y);
                    open.push(lm[20].y < lm[18].y);
                    return open;
                };

                // Helper Pellizco (Distancia Pulgar-칈ndice)
                const checkPinch = (lm) => {
                    const p4 = getPos(lm, 4);
                    const p8 = getPos(lm, 8);
                    return p4.distanceTo(p8) < 60;
                };

                // Procesar manos
                let h1L = results.multiHandLandmarks[0];
                let h2L = (results.multiHandLandmarks.length > 1) ? results.multiHandLandmarks[1] : h1L;

                // Asignar posiciones
                const p1 = getPos(h1L, 9); // Centro mano 1
                const p2 = getPos(h2L, 9); // Centro mano 2
                
                // Ordenar izquierda/derecha visualmente
                if (p1.x < p2.x) {
                    hand1.lerp(p1, 0.5);
                    hand2.lerp(p2, 0.5);
                    fingers.left = checkFingers(h1L);
                    fingers.right = checkFingers(h2L);
                    isPinchingLeft = checkPinch(h1L);
                    isPinchingRight = checkPinch(h2L);
                } else {
                    hand1.lerp(p2, 0.5);
                    hand2.lerp(p1, 0.5);
                    fingers.left = checkFingers(h2L);
                    fingers.right = checkFingers(h1L);
                    isPinchingLeft = checkPinch(h2L);
                    isPinchingRight = checkPinch(h1L);
                }

                // Calcular tama침o de mano (para detectar empuj칩n/profundidad relativa)
                // Distancia entre Mu침eca (0) y Medio (12)
                const size1 = Math.hypot(h1L[0].x - h1L[12].x, h1L[0].y - h1L[12].y);
                const size2 = Math.hypot(h2L[0].x - h2L[12].x, h2L[0].y - h2L[12].y);
                // Escalar a p칤xeles aprox
                handSize = (size1 + size2) / 2 * window.innerWidth;

            } else {
                isHandDetected = false;
                isPinchingLeft = false;
                isPinchingRight = false;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        cameraUtils.start();

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        initThree();

    </script>
</body>
</html>
